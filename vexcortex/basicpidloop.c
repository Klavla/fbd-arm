#pragma config(Sensor, dgtl1,  shoulderEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  elbowEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           shoulderMotor, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port10,          elbowMotor,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float shoulderLen = 1;
const float foreLen = 1;
const float ticksPerRadian = 512 / (2 * PI);

//This struct will hold all the data a pid loop needs to operate
typedef struct
{
	float P, I, D, prevError, totalError;
	long prevTime;
	short setpoint;
	bool reverseOutput;
	tMotor plant;
	tSensors sensor;
} PIDData;

//This function calculates the pid terms and applies it to the motor
void calculatePID(PIDData pid)
{
	short error = SensorValue[pid.sensor] - pid.setpoint; //Calculate error
	short de = error - pid.prevError; //Calculate change in error (for integral and derivitive)
	pid.prevError = error; //prevError is now current error

	long dt = time1[T1] - pid.prevTime; //Change in time (milliseconds)

	float output = pid.P * error; //Add proportional term (current error)

	pid.totalError =+ error * dt; //Calculate integral (area under error curve)
	output =+ pid.I * pid.totalError; //Add integral term

	output =- pid.D * de / dt; //Subract derivative term (slope of error)

	motor[pid.plant] = pid.reverseOutput ? -output : output; //Set motor to output, reversing if reverseOutput is true
}

//Several parts of the pid are time-sensitive, so we wait to initialize them until as late as possible
void initPID(PIDData pid)
{
	pid.prevError = SensorValue[pid.sensor] - pid.setpoint; //Find the initial error (for derivative)
	pid.prevTime = time1[T1]; //Find the initial time (for integral and derivative
}

//     elbow
//      \/
//  |   .
// y|  / \
//  | /   * < wrist
//  |/______
//  /\  x
//shoulder

float calculateShoulderAngle(float x, float y)
{
	return asin((pow(y, 2) + pow(x, 2) + pow(shoulderLen, 2) - pow(foreLen, 2)) /
	  (2 * shoulderLen * sqrt(pow(y, 2) + pow(x, 2)))) - atan2(x, y);
}

float calculateElbowAngle(float x, float y, float shoulderAngle)
{
	return acos((x - (shoulderLen * cos(shoulderAngle)) / foreLen)) + PI - shoulderLen;
}

//The main robot function
task main()
{
	//Construct shoulder PID
	struct PIDData shoulderPID;
	shoulderPID.P = 0;
	shoulderPID.I = 0;
	shoulderPID.D = 0;
	shoulderPID.setpoint = 200;
	shoulderPID.reverseOutput = false;
	shoulderPID.plant = shoulderMotor;
	shoulderPID.sensor = shoulderEncoder;

	//Construct elbow PID
	struct PIDData elbowPID;
	elbowPID.P = 0;
	elbowPID.I = 0;
	elbowPID.D = 0;
	elbowPID.setpoint = 200;
	elbowPID.reverseOutput = false;
	elbowPID.plant = elbowMotor;
	elbowPID.sensor = elbowEncoder;

	//Initialize the pids (set initial time and error)
	initPID(shoulderPID);
	initPID(elbowPID);

	const float targetX = 2;
	const float targetY = 2;

	//Everything is in radians, because C
	float shoulderAngle = calculateShoulderAngle(targetX, targetY);
	float elbowAngle = calculateElbowAngle(targetX, targetY, shoulderAngle);

	//shoulderPID.setpoint = shoulderAngle * ticksPerRadian;
	//elbowPID.setpoint = elbowAngle * ticksPerRadian;

	//Main robot loop
	while(true)
	{
		//Calculate and apply the pids
		calculatePID(shoulderPID);
		calculatePID(elbowPID);
	}
}
